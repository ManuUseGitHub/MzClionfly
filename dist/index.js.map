{
  "version": 3,
  "sources": ["../src/utils.ts", "../src/optionActivations.ts", "../src/optionCombinatorChecker.ts", "../src/index.ts"],
  "sourcesContent": ["const toObejct = (arr: any[]) => Object.assign({}, ...arr);\nconst removeCharacterRepetition = (str: string) => [...new Set(str.split(''))].join(\"\");\nconst startsNotHyphenized = (str: string) => /^[^\\-]/.test(str);\nconst startsAsAShortOption = (str: string) => /^[\\-][^\\-]/.test(str);\nconst onlyDefined = (array : any[]) => array.filter((x: any) => x !== undefined);\nconst firstBitIndex = (x:string) => x.indexOf(\"1\");\n\nexport {\n    toObejct,\n    removeCharacterRepetition,\n    startsAsAShortOption,\n    startsNotHyphenized,\n    onlyDefined,\n    firstBitIndex\n}", "import { Option } from \"commander\";\nimport { removeCharacterRepetition, startsAsAShortOption, startsNotHyphenized, toObejct } from \"./utils\";\n\ntype ActivationOptionType =\n    { [x: string]: boolean }\n\nconst hyphenIzeArgv = () => {\n\n    let argv = process.argv;\n\n    if(argv[2]){\n        if (startsNotHyphenized(argv[2])) {\n            argv[2] = '-' + removeCharacterRepetition(argv[2]);\n            \n        }\n    \n        if(startsAsAShortOption(argv[2])){\n            argv[2] = removeCharacterRepetition(argv[2])\n        }\n    }\n\n    return argv;\n}\n\nconst defined = (x: string) => x !== undefined;\nconst activate = (x: string) => ({ [x!]: true });\n\nconst getActivatedOptions = (options: readonly Option[]): ActivationOptionType => {\n    const argv = hyphenIzeArgv();\n    const effectives = argv.slice(2);\n\n    const activated = getActivationWithLongNames(effectives, options)\n    return activated\n}\n\nconst getOptionsByLetters = (options: readonly Option[]) => {\n    return options.map(o => ({ [o.short!.charAt(1)]: o.long?.substring(2) })!);\n}\n\nconst getOptionsByLongName = (options: readonly Option[]) => {\n    return options.map(o => (o.long?.substring(2)));\n}\n\nconst getActivationWithShortNames = (argv: string, options: readonly Option[]): string[] => {\n\n    const optionsByLetter = toObejct(getOptionsByLetters(options));\n\n    return argv.substring(1).split('')\n        .map(x => (optionsByLetter[x]));\n}\n\n\nconst makeListOfEffectiveLongOptions = (effectives: string[]): any[] => {\n    return effectives.map(x => {\n        let m = null;\n        return (m = /^--(?<option>.+)/.exec(x)) ?\n            m.groups!.option :\n            x\n    });\n}\n\nconst makeListOfShortsEffectiveOptions = (effectives: string[], cb: (x: string) => any) => {\n    let activatedShortOptions: ActivationOptionType = {};\n    effectives.map(x => {\n        if (/^\\-[^\\-]/.test(x)) {\n            activatedShortOptions = Object.assign(activatedShortOptions, cb(x))\n        }\n    })\n    return activatedShortOptions;\n}\n\nconst collectShortOptions = (effectives: string[], options: readonly Option[]) => {\n    return makeListOfShortsEffectiveOptions(effectives,\n        x => toObejct(getActivationWithShortNames(x, options)\n            .filter(defined)\n            .map(activate)\n        )\n    );\n}\n\nconst collectLongOptions = (effectives: string[], optionsLongNames: (string | undefined)[]) => {\n    return toObejct(makeListOfEffectiveLongOptions(effectives)\n        .filter(x => optionsLongNames.includes(x))\n        .map(activate)\n    );\n}\n\nconst getActivationWithLongNames = (effectives: string[], options: readonly Option[]) => {\n    return Object.assign(\n        collectShortOptions(effectives, options),\n        collectLongOptions(effectives, getOptionsByLongName(options))\n    );\n}\n\nexport { ActivationOptionType, getActivatedOptions }", "import { OptionValues } from \"commander\"\nimport { ActivationOptionType } from \"./optionActivations\"\nimport { Combinable, MaskConfig } from \"./types\";\n\nclass Checker implements Combinable {\n    constructor(private maskConfig: MaskConfig) { }\n\n    public isViableOptions = (options: ActivationOptionType) => {\n        const keys: string[] = Object.keys(options);\n        if (keys.length == 1) {\n            const result = this.isViableUnary(options);\n            return result;\n        } else if (keys.length > 1) {\n            return this.isViableCombination(options);\n        }\n        return 0;\n    }\n\n    private combinationToPick = (options: OptionValues): string[] => {\n        return Object.keys(options)\n            .map(o => o.charAt(0))\n            .filter(x => this.maskConfig.combinations[x]);\n    }\n\n    private findCombination = (options: OptionValues) => {\n        const toPick = this.combinationToPick(options);\n        if (toPick.length > 1) {\n            return \"0\";\n        }\n\n        if (toPick.length) {\n            const entry: string = toPick[0];\n            return this.maskConfig.combinations[entry] || \"0\";\n        }\n    }\n\n    private isViableUnary = (options: ActivationOptionType) => {\n\n        const selectiveWordsPipeSeparated = `(${this.maskConfig.pureUnaries.join(\"|\")})`;\n        const firstOption: string = Object.keys(options)[0];\n        return RegExp(selectiveWordsPipeSeparated)\n            .test(firstOption) ? 1 : 0;\n    }\n\n    private setIfMatches = (options: ActivationOptionType, ...keys: any[]) => {\n        return keys\n            .map(x => options[x] ? \"1\" : \"0\")\n            .join(\"\");\n    }\n\n    private isViableCombination = (options: ActivationOptionType) => {\n\n        const combinatory = this.findCombination(options)!;\n        const mask = this.setIfMatches(options, ...this.maskConfig.orderKeys);\n\n        return parseInt(combinatory, 2) & parseInt(mask, 2)\n    }\n}\n\nexport { Checker }", "import { ActivationOptionType, getActivatedOptions } from \"./optionActivations\";\nimport { Checker } from \"./optionCombinatorChecker\";\n\nexport { ActivationOptionType, getActivatedOptions, Checker }"],
  "mappings": "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",
  "names": ["toObejct", "arr", "exports", "removeCharacterRepetition", "str", "startsNotHyphenized", "startsAsAShortOption", "onlyDefined", "array", "x", "firstBitIndex", "utils_1", "hyphenIzeArgv", "argv", "defined", "activate", "getActivatedOptions", "options", "effectives", "getActivationWithLongNames", "getOptionsByLetters", "o", "_a", "getOptionsByLongName", "getActivationWithShortNames", "optionsByLetter", "makeListOfEffectiveLongOptions", "m", "makeListOfShortsEffectiveOptions", "cb", "activatedShortOptions", "collectShortOptions", "collectLongOptions", "optionsLongNames", "Checker", "maskConfig", "keys", "toPick", "entry", "selectiveWordsPipeSeparated", "firstOption", "combinatory", "mask"]
}
